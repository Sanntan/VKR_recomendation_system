# Нагрузочное тестирование телеграм-бота

Этот документ описывает устройство скрипта [`scripts/load_test_bot.py`](../scripts/load_test_bot.py),
процедуру запуска нагрузочного тестирования, формат отчётных файлов и способы
их интерпретации.

## Общая архитектура скрипта

Скрипт поддерживает два режима работы:

* **`synthetic`** — автономный стресс-тест без обращений к серверам Telegram.
* **`live`** — сценарии отправляются в реальные чаты через Bot API (требуется
  действительный токен и список `chat_id`).

Основные компоненты:

1. **`build_application`** из `src/bot/main.py`
   создаёт `Application` с теми же обработчиками, что и в боевой версии бота.
2. **`FakeBotAPIRequest`** наследуется от `telegram.request.BaseRequest` и
   перехватывает все запросы к Bot API. Вместо HTTP-вызовов он возвращает
   синтетические ответы, что позволяет запускать тест без сети и внешних
   зависимостей. Дополнительно можно задать искусственную задержку с помощью
   параметра `--transport-delay`.
3. **`ScenarioFactory`** генерирует последовательности объектов `Update` для
   эмуляции поведения пользователя. Сценарий `full` повторяет путь
   `/start` → ввод e-mail → переходы по кнопкам меню и отправку обратной связи.
   Сценарий `simple` ограничивается текстовыми сообщениями и подходит для
   live-режима. Доля корректных/некорректных e-mail управляется параметром
   `--valid-email-ratio`.
4. **`process_update`** и **`run_load_test`** распараллеливают обработку
   обновлений, используя семафор для ограничения одновременных задач.
5. **`LoadTestMetrics`** фиксирует задержки обработки, группирует их по типам
   (`message`, `callback`), считает квантили и собирает ошибки. Итоговые данные
   сохраняются в JSON, а при указании `--raw-metrics-file` — ещё и в CSV.

## Алгоритм работы

1. Скрипт разбирает аргументы командной строки и настраивает логирование в
   файл `logs/load_test.log` (значение можно изменить флагом `--log-file`).
2. Создаётся приложение Telegram Bot API. В режиме `synthetic` используется
   поддельный транспорт и фиксированный токен (если не указан собственный),
   в `live` — стандартный транспорт библиотеки и реальный токен бота.
3. Для каждого виртуального пользователя (определяется `--users`) и каждой
   итерации (`--iterations`) генерируется сценарий взаимодействия.
4. Все обновления отправляются в очередь `Application.process_update`, а
   фактическое количество одновременно исполняемых задач ограничивает флаг
   `--concurrency`.
5. После завершения теста метрики выгружаются в JSON (`--metrics-file`) и,
   при необходимости, в CSV (`--raw-metrics-file`).

## Аргументы командной строки

| Параметр | По умолчанию | Описание |
| --- | --- | --- |
| `--users` | `50` | Количество виртуальных пользователей. |
| `--iterations` | `5` | Сколько раз каждый пользователь повторяет сценарий. |
| `--concurrency` | `20` | Максимальное число одновременных обновлений. |
| `--valid-email-ratio` | `0.8` | Доля корректных e-mail среди всех пользователей. |
| `--inter-update-delay` | `0.0` | Задержка (секунды) между обновлениями одного пользователя. |
| `--transport-delay` | `0.0` | Искусственная задержка внутри `FakeBotAPIRequest` (только `synthetic`). |
| `--log-file` | `logs/load_test.log` | Путь к файлу с логами выполнения. |
| `--metrics-file` | `logs/load_test_metrics.json` | Путь к JSON с агрегированными метриками. |
| `--raw-metrics-file` | `—` | При указании сохраняет CSV с покадровыми задержками. |
| `--token` | значение `BOT_TOKEN` из окружения или `TEST:TOKEN` | Токен бота. |
| `--log-level` | `INFO` | Уровень логирования (`DEBUG`, `INFO`, `WARNING`, `ERROR`). |
| `--seed` | `—` | Фиксированный seed генератора случайных чисел для повторяемости сценариев. |
| `--mode` | `synthetic` | Режим тестирования: `synthetic` или `live`. |
| `--scenario` | `full` | Тип сценария: `full` (с callback-кнопками) или `simple` (только сообщения). |
| `--chat-ids` | `—` | Список `chat_id` через запятую для режима `live`. |

## Пример запуска

```bash
python scripts/load_test_bot.py \
  --users 100 \
  --iterations 3 \
  --concurrency 40 \
  --valid-email-ratio 0.7 \
  --inter-update-delay 0.05 \
  --transport-delay 0.01 \
  --log-level INFO \
  --log-file logs/load_test.log \
  --metrics-file logs/summary.json \
  --raw-metrics-file logs/raw.csv
```

## Формат отчётных файлов

### CSV с сырыми задержками (`--raw-metrics-file`)

Файл содержит три столбца:

- `update_index` — порядковый номер обработанного обновления;
- `type` — тип обновления (`message`, `callback`, `other`);
- `latency_ms` — длительность обработки в миллисекундах.

Пример строк:

```
update_index,type,latency_ms
1,message,0.206
2,message,0.347
3,callback,0.192
...
```

Каждая строка соответствует одному вызову `Application.process_update`. По
этому файлу удобно строить графики распределения задержек и находить выбросы.

### JSON со сводными метриками (`--metrics-file`)

В JSON записывается словарь со следующими полями:

- `total_updates` — общее количество обработанных обновлений;
- `errors` — число исключений во время обработки;
- `duration_sec` — суммарное время выполнения теста;
- `throughput_rps` — пропускная способность (обновлений в секунду);
- `latency_overall` — агрегированные метрики задержек по всем обновлениям;
- `latency_by_type` — такие же метрики, но для отдельных типов (`message`, `callback`);
- `error_messages` — список текстов исключений (если были).

Для предоставленного примера:

```json
{
  "total_updates": 26,
  "errors": 0,
  "duration_sec": 0.0052,
  "throughput_rps": 5004.62,
  "latency_overall": {
    "avg": 0.000128,
    "median": 0.000120,
    "p95": 0.000203,
    "p99": 0.000312
  },
  "latency_by_type": {
    "message": {
      "avg": 0.000172,
      "median": 0.000143,
      "p95": 0.000312,
      "p99": 0.000340
    },
    "callback": {
      "avg": 0.000115,
      "median": 0.000120,
      "p95": 0.000150,
      "p99": 0.000184
    }
  },
  "error_messages": []
}
```

Такие значения говорят о том, что тест завершился без ошибок, обработал 26
обновлений примерно за 5 мс и показал условную пропускную способность ~5000
обновлений в секунду. Задержки находятся в диапазоне 0.09–0.34 мс, причём
сообщения обрабатываются чуть дольше, чем callback-запросы (что логично из-за
валидации e-mail и переходов состояний).

### Лог-файл (`--log-file`)

Логи записываются одновременно в консоль и в указанный файл. Если файл пустой,
значит в ходе теста не возникло сообщений на выбранном уровне логирования.
Чтобы увидеть более подробные сообщения, запустите тест с `--log-level DEBUG`.

## Рекомендации по анализу

1. **Сравнивайте метрики разных прогонов.** Фиксируйте `--seed`, чтобы сценарии
   были сопоставимы, и варьируйте параметры нагрузки.
2. **Используйте CSV для построения графиков.** Набросьте гистограммы или
   временные ряды по `latency_ms`, чтобы заметить «хвосты» распределения.
3. **Имитируйте сетевые задержки.** Параметр `--transport-delay` доступен в
   режиме `synthetic` и помогает оценить поведение бота при медленном соединении.
4. **Собирайте логи ошибок.** При появлении записей в `error_messages`
   сопоставьте их с соответствующими строками в CSV и записями журнала.

## Завершение теста

Скрипт сам корректно завершает приложение Telegram (`application.shutdown()`),
поэтому дополнительных действий не требуется. Все файлы отчётов остаются в
указанных путях и готовы к дальнейшему анализу.

## Работа в режиме live

1. Добавьте токен бота в файл `.env` (`BOT_TOKEN=...`) или передайте через
   переменную окружения/флаг `--token`.
2. Определите список тестовых чатов и передайте их идентификаторы с помощью
   `--chat-ids`. Допустимо указать несколько `chat_id`, разделённых запятыми.
3. Выберите сценарий `simple` (рекомендуется по умолчанию; сценарий `full`
   будет автоматически преобразован в `simple`, поскольку синтетические
   callback-запросы невалидны для реального Bot API).
4. Запустите тест с `--mode live`. Ответы бота будут отправляться в указанные
   чаты, а задержки и логи будут собраны в тех же файлах, что и в режиме
   `synthetic`.
